
------------- javascript ------------
1. what is this? 
2. what is difference between call and apply and other?
what is the use of arrow functions?
3. what is hoisting?
4. what is lexical scoping?
5. what is closure?
6. what is babel?
7. what is webpack?
8. what are some ES6 features?
what is map and set in js
9. what is callback hell?
8. what is difference between promises and async and await?
10. what is chaining in js?
11. what is debouncing and throttling?
13. what is callstack?
14. what is Event loop, microtask and macrotasks
15. what is currying?
16. what are different types of promises?
17. difference between forEach and map?
18. what is event bubbling? how do you avoid or use it?
19. what is strictMode and NonstrictMode ?
20. what is shallow copy and deep copy?
21. what is the difference between async-await and promises 
22. sorting in js
23. memory management in js
24. what is difference between deepcopy and shallowcopy

25. circular reference 
26. shallow and deepcopy 
-----------------------
1. what is this? 

In JavaScript, the this keyword is a special identifier that refers to the context in which a function is executed. 
Its value is determined at runtime, based on how the function is called, rather than where it is defined. 
This dynamic nature can sometimes make this a source of confusion for developers.

Here's a breakdown of how this behaves in different scenarios:

Global Context:
    When this is used outside of any function or object, it refers to the global object. 
    In a web browser, this is typically the window object. 
    In Node.js, it's the global object. 

Object Methods:
    When a function is called as a method of an object (e.g., object.method()), this inside that method refers to the object itself. 
    This allows the method to access and manipulate the object's properties and other methods.

Standalone Functions:
    When a function is called as a standalone function (not attached to an object, e.g., functionName()), this typically refers to the global object in non-strict mode. 
    In strict mode ('use strict';), this will be undefined. 

Constructor Functions:
    When a function is called with the new keyword (e.g., new ConstructorFunction()), it acts as a constructor. 
    In this case, this inside the constructor refers to the newly created instance of the object.

Event Handlers:
    In an event listener, this typically refers to the DOM element that triggered the event. 

Explicit Binding (call, apply, bind):
    JavaScript provides methods like call(), apply(), and bind() to explicitly set the value of this for a function call.
    call() and apply() immediately invoke the function with a specified this value and arguments.
    bind() creates a new function with a permanently bound this value, which can be invoked later.

Arrow Functions:
    Arrow functions (=>) handle this differently. They do not have their own this binding. Instead, they lexically inherit this from their parent scope at the time they are defined. 
    This makes them useful for preserving context in callbacks and other scenarios where this might otherwise change unexpectedly. 

-------------- difference between call apply and bind -----------------

The primary difference is that call() and apply() immediately invoke a function, while bind() creates a new function that can be called later. 
call() accepts arguments individually, apply() accepts arguments as an array, and bind() creates a new function with a specified this context and can also pre-fill some arguments. 

Here's a breakdown of each:

call()
Purpose: Invokes a function immediately. 
Arguments: Takes the this context as the first argument, followed by the function's arguments provided individually. 
Use Case: When you know all the arguments ahead of time and want to pass them one by one. 
Example: function.call(thisContext, arg1, arg2) 

apply()
Purpose: Invokes a function immediately. 
Arguments: Takes the this context as the first argument, followed by an array of the function's arguments. 
Use Case: When the arguments for the function are dynamic or are already in an array. 
Example: function.apply(thisContext, [arg1, arg2]) 

bind()
Purpose: Creates and returns a new function with a specified this value. 
Arguments: Takes the this context as the first argument, followed by any arguments you want to pre-fill. 
Use Case: When you need to set the this context and/or pre-fill arguments for a function that will be called later, such as in event handlers or callbacks. 
Example: let newFunction = function.bind(thisContext, arg1); 

Key Takeaways
Execution: call() and apply() execute the function right away, while bind() returns a new, bound function that you must invoke later. 
Arguments: Use call() for individual arguments and apply() for array arguments. 
this Context: All three methods allow you to explicitly set the this value for the function. 

// Define a 'person' object and a 'greet' function
const person = {
  name: "Alice",
  greeting: "Hello",
};

function greet(language, punctuation) {
  console.log(`${this.greeting}, my name is ${this.name}${punctuation}`);
  console.log(`Language used: ${language}`);
}

// 1. Using `call()`
console.log("--- Using call() ---");
// Arguments are passed individually
greet.call(person, "English", "!"); // Output: Hello, my name is Alice! Language used: English

// 2. Using `apply()`
console.log("--- Using apply() ---");
// Arguments are passed as an array
const args = ["French", "?"];
greet.apply(person, args); // Output: Hello, my name is Alice? Language used: French

// 3. Using `bind()`
console.log("--- Using bind() ---");
// `bind` returns a new function, which is then called separately

const boundGreet = greet.bind(person, "German");
boundGreet("..."); // Output: Hello, my name is Alice... Language used: German

-------what is the use of arrow functions?--------------

Arrow functions in JavaScript, introduced in ES6, provide a concise syntax for writing function expressions and offer distinct behavior regarding the this keyword. Their primary uses include:
Concise Syntax: Arrow functions allow for shorter function definitions, especially for simple, single-expression functions. This can improve code readability and reduce verbosity.

JavaScript

    // Traditional function expression
    const add = function(a, b) {
      return a + b;
    };

    // Arrow function
    const addArrow = (a, b) => a + b;

Lexical this Binding: This is a key advantage of arrow functions. Unlike traditional functions, arrow functions do not create their own this context. Instead, they inherit this from their surrounding (lexical) scope. 
This eliminates the need for bind(), call(), or apply() in many scenarios, particularly within object methods or event handlers, preventing common this binding issues.

JavaScript

    class MyComponent {
      constructor() {
        this.value = 10;
      }

      // Traditional function, 'this' would be undefined without binding
      handleClickTraditional() {
        setTimeout(function() {
          console.log(this.value); // 'this' refers to the global object or undefined in strict mode
        }, 100);
      }

      // Arrow function, 'this' correctly refers to the MyComponent instance
      handleClickArrow() {
        setTimeout(() => {
          console.log(this.value); // 'this' correctly refers to the MyComponent instance
        }, 100);
      }
    }

Callbacks and Higher-Order Functions: Arrow functions are well-suited for use as callback functions in methods like map(), filter(), reduce(), forEach(), and setTimeout(), where their conciseness and this binding behavior are beneficial.

JavaScript

    const numbers = [1, 2, 3];
    const doubledNumbers = numbers.map(num => num * 2); // Concise callback

In summary, arrow functions are used for writing more concise code and, more importantly, for managing the this keyword consistently, especially in contexts where this binding can be problematic with traditional function expressions.

--------- what is hoisting -------------

Hoisting in JavaScript is a behavior where declarations of variables and functions are conceptually moved to the top of their containing scope during the compilation phase, before the code is executed. 
This means that you can use a variable or call a function before it is declared in your code. 

Key aspects of Hoisting:

Declarations are hoisted, not initializations: Only the declaration part of a variable or function is moved to the top, not its assignment or definition.
Variable Hoisting (with var): When var is used, the declaration is hoisted to the top of its function or global scope, and the variable is initialized with undefined.

JavaScript

    console.log(myVar); // Output: undefined
    var myVar = 10;
    console.log(myVar); // Output: 10

Function Hoisting: Function declarations are fully hoisted, meaning both the function name and its definition are available at the top of their scope.

JavaScript

    myFunction(); // Output: Hello from myFunction!
    function myFunction() {
      console.log("Hello from myFunction!");
    }
let and const and the Temporal Dead Zone (TDZ): 
While let and const declarations are also hoisted, they are not initialized with undefined like var. 
Instead, they enter a "Temporal Dead Zone" (TDZ) from the beginning of their block scope until their actual declaration line. 
Accessing them within the TDZ will result in a ReferenceError.

JavaScript

    // console.log(myLetVar); // ReferenceError: Cannot access 'myLetVar' before initialization
    let myLetVar = 20;
    console.log(myLetVar); // Output: 20

Function Expressions and Arrow Functions: These are not hoisted in the same way as function declarations. They behave like var, let, or const variables depending on how they are declared.

JavaScript

    // myFuncExpression(); // TypeError: myFuncExpression is not a function (if declared with var)
    // myArrowFunc(); // ReferenceError: Cannot access 'myArrowFunc' before initialization (if declared with let/const)

    var myFuncExpression = function() {
      console.log("Hello from function expression!");
    };
    const myArrowFunc = () => {
      console.log("Hello from arrow function!");
    };

------------- what is lexical scoping and closure --------------
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures#creating_closures_in_loops_a_common_mistake

lexical scoping, which describes how a parser resolves variable names when functions are nested. 
The word lexical refers to the fact that lexical scoping uses the location where a variable is declared within the source code to determine where that variable is available. 
Nested functions have access to variables declared in their outer scope.

Closures
A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). 
In other words, a closure gives a function access to its outer scope.
In JavaScript, closures are created every time a function is created, at function creation time.

---------- what is babel -------------

Babel is a JavaScript compiler, also known as a transpiler. Its primary function is to convert modern JavaScript code (ECMAScript 2015+ or ES6+) into a backward-compatible version of JavaScript that can run in older browsers or environments. 

Key functions of Babel:

Syntax Transformation: 
    Babel transforms newer JavaScript syntax, such as arrow functions, const/let declarations, and class syntax, into equivalent ES5 code that older engines can understand.

Polyfilling: 
    It can polyfill missing JavaScript features (like Promise or Array.prototype.includes) that might not be available in the target environment, ensuring consistent behavior across different platforms. This often involves integrating with a third-party polyfill library like core-js.

Source Code Transformations: 
    Beyond core syntax, Babel can also be used for various source code transformations, including converting JSX (used in React) into standard JavaScript function calls.

---------- what is webpack or trauser -----------------

Webpack is a static module bundler for modern JavaScript applications. It is a powerful tool commonly used in web development, especially with front-end frameworks like React, Angular, and Vue.js. 

Here's a breakdown of what Webpack does:

Module Bundling: Webpack's core function is to take all the individual modules (JavaScript files, CSS files, images, etc.) in your project and combine them into one or more optimized bundles. This process helps reduce the number of HTTP requests a browser needs to make, leading to faster loading times for your web application.

Dependency Graph Creation: Webpack analyzes your project's code and builds a dependency graph, starting from designated "entry points." This graph maps out how different modules depend on each other, ensuring that all necessary code is included in the final bundles and in the correct order.

Asset Management: Beyond JavaScript, Webpack can handle various types of assets. Through the use of "loaders," it can transform and bundle files like:
CSS (e.g., converting Sass/Less to CSS, handling CSS Modules)
Images (e.g., optimizing, inlining small images)
Fonts
Other static assets

Code Optimization: Webpack offers various features to optimize your code for production, including:

Minification: Reducing file sizes by removing unnecessary characters (whitespace, comments).

Tree Shaking: Eliminating unused code to further decrease bundle size.

Code Splitting: Dividing your application into smaller, on-demand loaded chunks to improve initial page load performance.

Extensibility with Plugins: Webpack's functionality can be extended using "plugins." These allow you to hook into different stages of the compilation process for advanced operations like optimizing assets, defining environment variables, or generating HTML files.

In essence, Webpack streamlines the development process by automating the bundling, optimization, and transformation of your application's assets, making it easier to manage complex projects and deliver high-performance web applications.


------------- what are some ES6 features? ---------- 
ES6 (ECMAScript 2015) introduced significant features to JavaScript, including arrow functions for concise function syntax, let and const for block-scoped variables, template literals for easier string formatting, destructuring assignment to extract data from arrays and objects, and class definitions for object-oriented programming. Other key features include modules (import/export), default and rest parameters, spread operator, and the Promise object for handling asynchronous operations.  

Key ES6 Features

Arrow Functions: Provide a shorter syntax for writing functions and handle this differently than traditional functions. 

let and const: Introduce block-scoped variables, offering more precise control over variable scope compared to the previous var. 

Template Literals: Use backticks (`) to create strings, allowing for easy embedding of expressions and multi-line strings. 

Destructuring Assignment: Simplifies extracting values from arrays or properties from objects into distinct variables. 

Class Definitions: Offer a more structured and readable way to create objects and implement inheritance using the class keyword. 

Modules (import/export): Enable code organization into reusable pieces by allowing you to export and import data between files. 

Default Parameters: Allow you to set default values for function parameters if no arguments are provided during a call. 

Rest Parameters: Use the ... syntax to collect an indefinite number of arguments into a single array. 

Spread Operator: The ... syntax, when used with arrays or objects, spreads their elements or properties into a new structure. 

Promises: Provide a more robust way to manage asynchronous operations and their eventual results or errors. 

Enhanced Object Literals: Introduce shorthand for properties, methods, and dynamic keys within objects. 

Map and Set: New data structures for storing collections of key-value pairs (Map) or unique values (Set), respectively. 

------------ what is what is map and set in js

In JavaScript, Map and Set are built-in objects introduced in ES6 (ECMAScript 2015) that provide more efficient and flexible ways to manage collections of data compared to traditional objects and arrays in certain scenarios.
Map
A Map is a collection of key-value pairs, similar to a JavaScript object, but with key differences:
Any data type as keys: Unlike plain objects where keys are implicitly converted to strings, Map allows keys of any data type (including objects, functions, or other Maps).
Ordered iteration: Elements in a Map are iterated in the order of their insertion.
size property: Provides a direct way to get the number of key-value pairs.
Common Map methods:
new Map(): Creates a new Map object.
map.set(key, value): Adds a new key-value pair or updates an existing key's value.
map.get(key): Retrieves the value associated with the specified key.
map.has(key): Checks if a key exists in the Map.
map.delete(key): Removes a key-value pair.
map.clear(): Removes all key-value pairs from the Map.
map.forEach((value, key, map) => { ... }): Iterates over the Map's entries.
Example of Map:
JavaScript

let userRoles = new Map();
userRoles.set('Alice', 'admin');
userRoles.set('Bob', 'editor');
userRoles.set('Charlie', 'viewer');

console.log(userRoles.get('Alice')); // Output: admin
console.log(userRoles.size); // Output: 3
userRoles.delete('Bob');
console.log(userRoles.has('Bob')); // Output: false
Set
A Set is a collection of unique values. It's similar to an array but automatically handles uniqueness, meaning duplicate values cannot be stored.
Unique values only: Any attempt to add a duplicate value to a Set is ignored.
Ordered iteration: Elements in a Set are iterated in the order of their insertion.
size property: Provides a direct way to get the number of unique values.
Common Set methods:
new Set([iterable]): Creates a new Set object, optionally initialized with values from an iterable (e.g., an array).
set.add(value): Adds a new value to the Set.
set.has(value): Checks if a value exists in the Set.
set.delete(value): Removes a value from the Set.
set.clear(): Removes all values from the Set.
set.forEach((value, valueAgain, set) => { ... }): Iterates over the Set's values.
Example of Set:
JavaScript

let uniqueNumbers = new Set();
uniqueNumbers.add(1);
uniqueNumbers.add(2);
uniqueNumbers.add(1); // This will be ignored as 1 already exists

console.log(uniqueNumbers.size); // Output: 2
console.log(uniqueNumbers.has(2)); // Output: true

let colors = new Set(['red', 'green', 'blue', 'red']);
console.log(colors); // Output: Set { 'red', 'green', 'blue' }
When to use them:
Use Map when you need to store data as key-value pairs and require keys of various data types, ordered iteration, or efficient key-based lookups and modifications.
Use Set when you need to store a collection of unique values and require efficient checks for value existence or removal of duplicates.


--------- 9. what is callback hell? ----------- 
Callback hell, also known as the "Pyramid of Doom," is a phenomenon in JavaScript that occurs when multiple asynchronous operations are nested within each other using callback functions. This creates deeply indented and complex code structures that become difficult to read, understand, maintain, and debug.
Characteristics of Callback Hell:
Deeply Nested Callbacks: When one asynchronous operation depends on the result of another, and you handle each subsequent operation within the callback of the previous one, it leads to multiple levels of nesting.
Reduced Readability: The increasing indentation makes the code visually resemble a pyramid, significantly hindering its readability and making it hard to follow the flow of execution.
Difficulty in Error Handling: Managing errors across multiple nested callbacks can be cumbersome and lead to repetitive error-handling logic in each callback.
Maintainability Issues: Modifying or refactoring code caught in callback hell becomes a challenging and error-prone task due to the tight coupling and complex structure.
Example of Callback Hell:
JavaScript

function getData(callback) {
  setTimeout(() => {
    const data = "User Data";
    callback(data);
  }, 1000);
}

function processData(data, callback) {
  setTimeout(() => {
    const processedData = data.toUpperCase();
    callback(processedData);
  }, 1000);
}

function displayData(processedData, callback) {
  setTimeout(() => {
    console.log("Displayed:", processedData);
    callback();
  }, 1000);
}

getData((data) => {
  processData(data, (processedData) => {
    displayData(processedData, () => {
      console.log("All operations complete.");
    });
  });
});

Solutions to Avoid Callback Hell:
Modern JavaScript provides several mechanisms to manage asynchronous operations more effectively and avoid callback hell:

Promises: Promises offer a cleaner way to handle asynchronous operations by allowing chaining of .then() methods for sequential operations and a single .catch() for error handling.

Async/Await: Built on top of Promises, async/await provides a more synchronous-looking syntax for asynchronous code, making it highly readable and easier to manage.

Modularization: Breaking down complex asynchronous logic into smaller, reusable functions can improve code organization and reduce nesting.

---------  what is difference between promises and async and await? -------------
Promises are JavaScript objects representing an asynchronous operation's eventual success or failure, while async/await is a modern syntax built on top of Promises to make asynchronous code appear more synchronous and readable. async functions always return a Promise, and await pauses an async function's execution until the awaited Promise resolves or rejects, allowing for simpler handling of complex asynchronous operations compared to traditional Promise chaining with .then() and .catch(). 
Promises
What they are:
A Promise is an object that holds the future result of an asynchronous operation. It can be in one of three states: pending, fulfilled (resolved), or rejected. 
How they work:
You handle their results and errors using methods like .then() for success and .catch() for errors. 
Pros:
They provide a foundational way to manage asynchronous operations, avoiding the complexity of nested callbacks. 
Cons:
For complex sequences of asynchronous tasks, Promise chaining can become difficult to read and maintain. 
Async/Await
What it is:
async/await is a syntactic feature that provides a cleaner, more synchronous-looking way to write asynchronous code. 
How it works:
The async keyword defines an asynchronous function that will always return a Promise.
The await keyword pauses the execution of an async function until a Promise settles (either resolves with a value or rejects with an error). 
Pros:
Readability: It makes asynchronous code look much more like traditional, synchronous code, which significantly improves readability and maintainability.
Error Handling: async/await allows you to use standard try...catch blocks for error handling, similar to synchronous code, making it more intuitive. 
Cons:
await can only be used inside an async function or at the top level of a module. 
Key Differences
Syntax:
Promises use .then() and .catch() for flow control, while async/await uses await within async functions for a more linear, synchronous-like structure. 
Readability:
async/await generally offers better readability, especially for complex, nested asynchronous operations. 
Relationship:
async/await is built on top of Promises; an async function inherently returns a Promise, and await is used to pause execution until a Promise is fulfilled. 

------------  what is chaining in js, method chaining and promise chaining---- 

In JavaScript, "chaining" primarily refers to method chaining, a technique that allows multiple methods to be called sequentially on the same object in a single line of code. This is achieved by having each method return the object instance itself, allowing the next method in the chain to be called directly on that returned object.
How Method Chaining Works:
Method Returns this: For method chaining to work, each method intended for chaining must explicitly return this. The this keyword, in the context of an object's method, refers to the current object instance.
Sequential Calls: When a method returns this, the result of that method call is the object itself. This enables you to immediately call another method on that same object, continuing the "chain" of operations.
Example:
Consider a Calculator object with methods for adding, subtracting, and multiplying:
JavaScript

class Calculator {
  constructor(initialValue = 0) {
    this.value = initialValue;
  }

  add(num) {
    this.value += num;
    return this; // Returns the Calculator instance
  }

  subtract(num) {
    this.value -= num;
    return this; // Returns the Calculator instance
  }

  multiply(num) {
    this.value *= num;
    return this; // Returns the Calculator instance
  }

  getResult() {
    return this.value;
  }
}

const myCalculator = new Calculator(10);

// Without chaining:
// myCalculator.add(5);
// myCalculator.subtract(2);
// myCalculator.multiply(3);
// console.log(myCalculator.getResult()); // Output: 39

// With chaining:
const result = myCalculator.add(5).subtract(2).multiply(3).getResult();
console.log(result); // Output: 39
Benefits of Method Chaining:
Improved Readability: Chaining can make code more concise and easier to follow, especially when performing a series of related operations on an object.
Reduced Redundancy: It eliminates the need to repeatedly reference the object variable for each method call.
Optional Chaining (a related but distinct concept):
While method chaining focuses on sequential method calls on the same object, optional chaining (?.) is a newer JavaScript feature that allows you to safely access properties or call methods on objects that might be null or undefined without causing an error.
JavaScript

const user = {
  name: "Alice",
  address: {
    city: "New York"
  }
};

// Without optional chaining (might throw error if 'address' is null/undefined):
// const city = user.address.city;

// With optional chaining:
const city = user.address?.city; // Safely accesses city if address exists
const zipCode = user.address?.zipCode; // Returns undefined if zipCode doesn't exist



Promise chaining is a JavaScript technique for executing a sequence of asynchronous operations, where each operation's result is passed to the next, creating a readable and manageable flow of tasks that avoids nested callbacks. This is achieved by using the .then() method, which returns a new promise, allowing you to chain multiple operations together and handle potential errors with a single .catch() block at the end of the chain. 
How it Works
Start with a Promise: Begin with an asynchronous operation that returns a promise, such as a fetch request or a custom function that returns a promise. 
Use .then() for Success: Call the .then() method on the promise to attach a callback function that will execute if the preceding promise is successfully resolved. 
Return a New Promise: The crucial part of chaining is that the callback function inside .then() should return a new promise. This returned promise then becomes the basis for the next .then() call. 
Data Transfer: The resolved value of the previous promise is passed as an argument to the .then() handler, which can then be used in the next asynchronous operation. 
Single Error Handler: A single .catch() block placed at the end of the chain can handle any rejections or errors that occur in any of the preceding promises, simplifying error management. 
Example
JavaScript

getUserData()
  .then(user => processUserData(user)) // processUserData returns a new promise
  .then(processedData => displayResults(processedData))
  .catch(error => console.error("An error occurred:", error));
getUserData() returns the first promise.
The first .then() receives the user data, and processUserData(user) returns the next promise.
The second .then() receives the processedData and calls displayResults().
If any step fails, the catch() block handles the error. 
Benefits
Sequential Execution: Ensures asynchronous tasks run in a specific, predictable order, one after the other. 
Reduced Callback Hell: Eliminates the deeply nested callback structures (callback hell) that can make asynchronous code hard to read and maintain. 
Improved Readability: Creates a cleaner, more linear structure for asynchronous operations, enhancing code maintainability. 
Simplified Error Handling: A single .catch() block at the end of the chain efficiently handles any errors that occur throughout the sequence. 



------------- what is debouncing ? ----------------
Debouncing in JavaScript is a technique used to control how frequently a function is executed, particularly in response to events that fire rapidly, such as user input (typing), window resizing, or scrolling. The core idea is to delay the execution of a function until a certain amount of time has passed without the event being triggered again.
How Debouncing Works:
Delaying Execution: When a debounced function is called, it doesn't execute immediately. Instead, it sets a timer.
Resetting the Timer: If the event triggers again within the specified delay period, the existing timer is cleared, and a new timer is set. This effectively "resets" the waiting period.
Executing the Function: The function is only executed once the specified delay period has completely elapsed without any further triggers of the event.
Example Use Cases:
Search Input Fields: Instead of making an API call for search suggestions on every keystroke, debouncing can delay the call until the user has paused typing for a short duration, reducing unnecessary network requests.
Window Resizing: When a user resizes a browser window, the resize event can fire many times. Debouncing ensures that the function handling the resize logic (e.g., re-calculating layout) only executes once the resizing has stopped.
Scroll Events: Similar to resizing, scroll events can fire frequently. Debouncing can be used to optimize actions that should only occur after the user has finished scrolling.
Implementing Debouncing:
A common way to implement a debounce function in JavaScript involves using setTimeout and clearTimeout.

function debounce(func, delay) {
  let timeoutId; // This will store the timer ID

  return function(...args) {
    const context = this; // Preserve the 'this' context

    clearTimeout(timeoutId); // Clear any existing timer

    timeoutId = setTimeout(() => {
      func.apply(context, args); // Execute the original function after the delay
    }, delay);
  };
}

// Example usage:
function handleSearchInput(event) {
  console.log("Searching for:", event.target.value);
  // In a real application, this would trigger an API call or other logic
}

const debouncedSearchHandler = debounce(handleSearchInput, 500); // 500ms delay

document.getElementById('searchInput').addEventListener('input', debouncedSearchHandler);

---------- what is throttling --------------
Throttling in JavaScript is a technique used to limit the rate at which a function can be executed. It ensures that a function is called at most once within a specified time interval, regardless of how many times the event that triggers it occurs. 
How it works:
When a function is throttled, it is allowed to execute immediately upon the first trigger. However, subsequent calls to that function within the defined "throttle delay" are ignored. Once the delay period has passed, the function can be executed again. This ensures a consistent execution rate, preventing the function from being called too frequently and potentially causing performance issues.
Example Implementation:
JavaScript

function throttle(func, delay) {
  let inThrottle;
  let lastFn;
  let lastTime;

  return function() {
    const context = this;
    const args = arguments;

    if (!inThrottle) {
      func.apply(context, args);
      lastTime = Date.now();
      inThrottle = true;
    } else {
      clearTimeout(lastFn);
      lastFn = setTimeout(function() {
        if (Date.now() - lastTime >= delay) {
          func.apply(context, args);
          lastTime = Date.now();
        }
      }, Math.max(delay - (Date.now() - lastTime), 0));
    }
  };
}

Use Cases:
Scrolling events: Limiting the frequency of functions that update UI elements or load content during scrolling.
Window resizing: Preventing excessive re-rendering or recalculations when the browser window is resized.
Mouse movement tracking: Optimizing performance for applications that track mouse position.
API rate limiting: Controlling the number of API calls made within a specific timeframe.


Comparison with Debouncing:

While both throttling and debouncing are optimization techniques for event handling, they differ in their approach:
Throttling: Executes the function at a consistent rate, allowing it to run periodically during an ongoing action.
Debouncing: Delays the execution of a function until a certain period of inactivity has passed after the last trigger.
The choice between throttling and debouncing depends on the specific requirements of the application and the desired behavior for handling frequent events.

----------- 13. what is callstack?

The JavaScript Call Stack is a fundamental mechanism within the JavaScript runtime environment that manages the execution of functions. It is a data structure that operates on the Last-In, First-Out (LIFO) principle

------------14. what is Event loop, microtask and macrotasks

The Event Loop, Microtasks, and Macrotasks are core components of JavaScript's execution model, where the Event Loop continuously orchestrates tasks by first checking the Call Stack, then processing the higher-priority Microtask Queue (for things like Promise callbacks and MutationObservers) until empty, and finally executing tasks from the lower-priority Macrotask Queue (for operations like setTimeout, user events, or network requests). This ensures asynchronous code is handled efficiently in a single-threaded environment by prioritizing immediate tasks over longer-running ones.

1. The Event Loop
What it is: A continuous process that monitors the Call Stack and the task queues (microtask and macrotask) to keep JavaScript running smoothly.
How it works:
It checks the Call Stack to see if any synchronous code needs to be executed.
If the Call Stack is empty, it then checks the Microtask Queue and executes all queued microtasks until that queue is empty.
Only after the microtask queue is empty does the event loop process one task from the Macrotask Queue.
It repeats this cycle, constantly checking for new tasks and maintaining the order of execution. 
2. Microtasks
What they are: High-priority asynchronous operations that are processed immediately after the current synchronous code finishes, but before the event loop moves on to the next macrotask.
Examples:
Promise callbacks (from .then(), .catch(), .finally())
MutationObserver callbacks
Calls to queueMicrotask()
Key Behavior: Microtasks are processed in a "run-to-completion" manner, meaning all microtasks in the queue will be executed before any macrotask is processed, even if they are added during the execution of another microtask. 
3. Macrotasks
What they are: Lower-priority asynchronous operations that are executed in distinct iterations of the event loop.
Examples:
Timer functions (setTimeout(), setInterval())
User interface events (like clicks or scrolls)
Network requests (I/O operations)
Key Behavior: Macrotasks are executed one at a time, each taking its own iteration of the event loop to run, but only after all current microtasks are complete. 
In Summary:
The event loop ensures that your JavaScript code runs without blocking the main thread by using these queues. It prioritizes urgent microtasks, then handles less urgent macrotasks, allowing for both immediate responsiveness and the smooth execution of longer-running operations. 

---------- 15. what is currying?

Currying is a functional programming technique that transforms a function with multiple arguments into a sequence of functions, each accepting a single argument. This process allows for the creation of new, specialized functions by "partially applying" or pre-filling some arguments, leading to more reusable and flexible code by maintaining the remaining arguments in the function's closure. 
How it Works
Instead of a function like f(a, b, c) being called all at once, a curried function is called as f(a)(b)(c). Each step returns a new function that holds the argument it received and waits for the next argument in the chain. 
javascript
// Regular function
function sum(a, b, c) {
  return a + b + c;
}

// Curried version
function curriedSum(a) {
  return function(b) {
    return function(c) {
      return a + b + c;
    };
  };
}

// Calling the curried function
let sum10 = curriedSum(10); // sum10 is now a function that waits for b
let sum10And20 = sum10(20); // sum10And20 is now a function that waits for c
let result = sum10And20(30); // result is 60
Benefits of Currying
Partial Application: You can create specialized functions with some arguments already defined. For example, you can create addTen(x) from an add(a, b) function by partially applying 10 as the first argument, resulting in addTen(x) = add(10)(x).
Code Reusability: By breaking down complex functions into smaller, single-argument functions, you can reuse these smaller functions in different contexts.
Readability and Maintainability: Currying can make code more readable by allowing complex logic to be broken into more manageable pieces, according to Medium.
Function Composition: It facilitates creating complex functions by composing simpler, curried functions together, notes DEV Community. 

------------16. what are different types of promises?

In JavaScript, promises are a way to handle asynchronous operations. While there's only one core Promise object, there are different static methods available on the Promise constructor that offer various ways to manage multiple promises concurrently. 
Promise States:
A Promise object can exist in one of three states: 
Pending: The initial state; the asynchronous operation has not yet completed.
Fulfilled (or Resolved): The operation completed successfully, and the promise has a resulting value.
Rejected: The operation failed, and the promise has a reason (error) for the failure.
Static Promise Methods:
These methods allow for coordination and management of multiple promises:
Promise.all(iterable):
Waits for all promises in the iterable to be fulfilled.
If all promises resolve, it returns a new promise that resolves with an array of their resolved values, in the same order as the input iterable.
If any promise in the iterable rejects, it immediately returns a new promise that rejects with the reason of the first rejected promise.
Promise.allSettled(iterable):
Waits for all promises in the iterable to be settled (either fulfilled or rejected).
Returns a new promise that resolves with an array of objects, each describing the outcome of a promise (e.g., { status: 'fulfilled', value: ... } or { status: 'rejected', reason: ... }).
Promise.race(iterable):
Returns a new promise that settles as soon as any of the promises in the iterable settles (either fulfills or rejects).
The returned promise adopts the state and value/reason of the first promise to settle.
Promise.any(iterable):
Waits for any promise in the iterable to be fulfilled.
If any promise fulfills, it returns a new promise that resolves with the value of the first fulfilled promise.
If all promises in the iterable reject, it returns a new promise that rejects with an AggregateError containing all the rejection reasons.
Example of using Promise.all:
JavaScript

const promise1 = Promise.resolve(3);
const promise2 = 42; // Not a promise, but treated as a resolved promise
const promise3 = new Promise((resolve, reject) => {
  setTimeout(resolve, 100, 'foo');
});

Promise.all([promise1, promise2, promise3]).then((values) => {
  console.log(values); // Expected output: [3, 42, "foo"]
});

------ difference between forEach and map ----------------

he forEach() and map() methods in JavaScript are both used to iterate over arrays, but they serve distinct purposes: 
Return Value:
forEach(): This method does not return a new array. It returns undefined. Its primary use is for performing side effects, such as logging values or modifying elements of the original array in place (though this is generally discouraged for maintaining immutability).
map(): This method returns a new array containing the results of calling a provided callback function on every element in the original array. The original array remains unchanged.
Purpose:
forEach(): Designed for iterating and performing an action for each element, without necessarily creating a new data structure. Think of it as a cleaner alternative to a traditional for loop when you don't need a return value.
map(): Designed for transforming the elements of an array into a new array of the same length, where each element in the new array is the result of applying a transformation function to the corresponding element in the original array.
Chaining:
forEach(): Cannot be directly chained with other array methods because it returns undefined.
map(): Can be easily chained with other array methods like filter(), reduce(), etc., because it returns a new array.
Example:
JavaScript

const numbers = [1, 2, 3];

// Using forEach()
let sum = 0;
numbers.forEach(num => {
  sum += num; // Side effect: modifying an external variable
});
console.log("Sum:", sum); // Output: Sum: 6

// Using map()
const doubledNumbers = numbers.map(num => num * 2); // Transformation: creating a new array
console.log("Original numbers:", numbers); // Output: Original numbers: [1, 2, 3]
console.log("Doubled numbers:", doubledNumbers); // Output: Doubled numbers: [2, 4, 6]

------- what is event bubbling, where to use it and where to avoid it ---------------

Event bubbling is a mechanism in the Document Object Model (DOM) where an event, such as a mouse click, starts at the target element and then propagates or "bubbles up" through all of its parent elements to the root of the document. 
In JavaScript, this process happens automatically, allowing parent elements to respond to events triggered by their descendants. This is the reverse of the "event capturing" phase, which moves from the top down to the target element. 
Where to use event bubbling (Event Delegation)
The primary and most powerful use of event bubbling is a design pattern known as event delegation. By attaching a single event listener to a common parent element, you can handle events for all its children, even those added to the page dynamically after the initial page load. 
Common use cases for event delegation:
Handling lists of items: Instead of adding an event listener to each <li> item in a list, you can add a single listener to the parent <ul>. When a list item is clicked, the event bubbles up to the <ul>, where the listener can identify the specific item clicked using event.target.
Dynamic content: If your page generates new elements, like a "To-Do" list where items are added by the user, a single event listener on the container will automatically work for all new items without needing to add a new listener for each one.
Optimizing performance: For large tables or long lists, adding hundreds or thousands of individual event listeners can consume a lot of memory. Event delegation dramatically reduces this overhead by using just one listener for all child elements.
UI components: Accordion menus, dropdowns, and modal dialogs can be managed efficiently. For example, a "click-outside-to-close" feature for a modal can be implemented with a single listener on the document that checks if the click occurred outside the modal's content. 
Where to avoid event bubbling
While useful, event bubbling can also cause problems if not managed correctly. You may need to stop the propagation to prevent unwanted side effects. 
When to avoid or stop bubbling:
Preventing unwanted parent events: If you have a nested element, such as a "Delete" button inside a card, you may want to prevent the button's click event from also triggering the parent card's click event. In this case, you would call event.stopPropagation() inside the button's event handler.
Heavy event handlers: In cases with a complex DOM hierarchy and an expensive event handler, bubbling can cause performance issues by repeatedly triggering the handler on many parent elements.
Conflicting behaviors: When nested elements have conflicting behaviors. For example, if clicking a parent expands a menu, but clicking a child link inside should only navigate, bubbling would trigger both actions unless stopped.
Non-bubbling events: Some events, like focus, blur, mouseenter, and mouseleave, do not bubble up the DOM. For these events, you cannot use event delegation on a parent, and must attach the listener directly to the target element. 

--------19. what is strictMode and NonstrictMode ?

Strict Mode and Non-Strict Mode (also sometimes referred to as "sloppy mode") are two distinct operational modes in JavaScript, primarily introduced to improve code quality, security, and error handling.

Non-Strict Mode (Default):
This is the default mode of operation in JavaScript.
It allows for more flexible, and sometimes less explicit, coding practices.
Certain actions that would be considered errors in strict mode are silently ignored or handled with implicit behaviors (e.g., undeclared variables becoming global).
It offers less robust error checking and can make it harder to detect potential bugs.

Strict Mode:
Introduced in ECMAScript 5 (ES5), strict mode is an opt-in, restricted variant of JavaScript.
It enforces stricter rules and provides better error checking, making it easier to catch common coding mistakes and potential security vulnerabilities.
It eliminates some "bad practices" and silent errors that exist in non-strict mode.
You can enable strict mode globally by placing 'use strict'; at the top of a script, or locally within a function. Modern JavaScript features like classes and modules automatically enable strict mode.

Key Differences and Benefits of Strict Mode:
Error Handling: Strict mode converts certain "bad syntax" or potentially problematic actions into actual errors, preventing silent failures and making bugs easier to identify.
Variable Declarations: In strict mode, using undeclared variables throws an error, preventing accidental global variable creation.
this Keyword Behavior: Inside a function, this defaults to undefined in strict mode (unless explicitly bound), preventing accidental modification of the global object. In non-strict mode, this would refer to the global object.
Disallowed Syntax: Strict mode prohibits the use of features considered problematic or deprecated, such as the with statement and arguments.caller/arguments.callee.
Read-Only Properties: Strict mode enforces the read-only nature of properties, throwing an error if you attempt to write to a non-writable property.
Duplicate Parameter Names: Strict mode disallows duplicate parameter names in function declarations, which can lead to confusion in non-strict mode.
In essence, strict mode promotes writing cleaner, more secure, and more maintainable JavaScript code by enforcing stricter rules and providing clearer error feedback.



